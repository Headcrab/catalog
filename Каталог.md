---
filenames: Каталог товаров*, Пример*
keys: Название, Цвет, Изображение
preview_size: 100
---

# Каталог

```dataviewjs
// Получаем свойства текущего файла
const currentFileProperties = dv.current().file.frontmatter;

// Получаем массив масок файлов из свойства filenames
const filenameMasks = currentFileProperties.filenames ? currentFileProperties.filenames.split(',').map(s => s.trim()) : ["Каталог товаров"];

// Получаем массив ключей из свойства keys
const keys = currentFileProperties.keys ? currentFileProperties.keys.split(',').map(s => s.trim()) : ["Название", "Цвет", "Вес", "Класс"];

// Функция для проверки соответствия имени файла маске
function matchesMask(filename, mask) {
    const regexPattern = mask.replace(/\*/g, '.*').replace(/\?/g, '.');
    const regex = new RegExp(`^${regexPattern}$`, 'i');
    return regex.test(filename);
}

// Получаем все файлы, соответствующие маскам
const catalogPages = dv.pages().where(p => filenameMasks.some(mask => matchesMask(p.file.name, mask)));

if (catalogPages.length === 0) {
    dv.paragraph(`Ошибка: Не найдено ни одной заметки, соответствующей маскам: ${filenameMasks.join(', ')}. Убедитесь, что такие заметки существуют.`);
} else {
    // Функция для парсинга содержимого заметки
    function parseItems(content, filePath) {
        const items = [];
        let currentItem = {};
        let lineNumber = 0;

        content.split('\n').forEach(line => {
            lineNumber++;
            if (line.startsWith('- Товар')) {
                if (Object.keys(currentItem).length > 0) {
                    items.push(currentItem);
                }
                currentItem = { lineNumber: lineNumber, filePath: filePath };
            } else if (line.trim().startsWith('- ')) {
                const [key, ...valueParts] = line.split(':').map(s => s.trim());
                const cleanKey = key.replace('- ', '');
                if (keys.includes(cleanKey)) {
                    const value = valueParts.join(':').trim();
                    currentItem[cleanKey] = value.split(',').map(v => {
                        v = v.trim();
                        // Обработка ссылок вида [Текст](Путь.md)
                        if (v.match(/\[.*?\]\(.*?\)/)) {
                            return v;
                        }
                        // Обработка вики-ссылок [[Путь|Текст]]
                        if (v.startsWith('[[') && v.endsWith(']]')) {
                            return v;
                        }
                        // Обработка медиа-ссылок вида ![[ссылка]]
                        if (v.startsWith('![[') && v.endsWith(']]')) {
                            return v;
                        }
                        return v;
                    });
                }
            }
        });

        if (Object.keys(currentItem).length > 0) {
            items.push(currentItem);
        }

        return items;
    }

    // Парсим содержимое всех найденных заметок каталога
    let allItems = [];
    for (const page of catalogPages) {
        const fileContent = await dv.io.load(page.file.path);
        allItems = allItems.concat(parseItems(fileContent, page.file.path));
    }

    // Добавьте эту фнкцию после объявления переменной allItems
    function getCurrentFolder() {
        const currentFilePath = dv.current().file.path;
        return currentFilePath.substring(0, currentFilePath.lastIndexOf("/") + 1);
    }

    if (allItems.length === 0) {
        dv.paragraph("Предупреждение: В заметках каталога товаров не найдено данных в ожидаемом формате.");
    } else {
        // Функция для применения фильтров
        function applyFilters(items, filters) {
            return items.filter(item => {
                return Object.entries(filters).every(([key, value]) => {
                    if (!value) return true; // Пропускаем пустые фильтры
                    const itemValues = item[key] || [];
                    return itemValues.some(itemValue => 
                        itemValue.toLowerCase().includes(value.toLowerCase())
                    );
                });
            });
        }

        // Создаем контейнер для всего содержимого
        const mainContainer = dv.el("div", "", {attr: {style: "font-family: Arial, sans-serif; color: #e0e0e0;"}});

        // Добавим стили для модального окна
        const modalStyles = `
            .image-modal {
                display: none;
                position: fixed;
                z-index: 1000;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.7);
                justify-content: center;
                align-items: center;
            }
            .modal-content {
                max-width: 90%;
                max-height: 90%;
            }
            .modal-content img {
                width: 100%;
                height: 100%;
                object-fit: contain;
            }
        `;

        // Добавим стили в документ
        const styleElement = document.createElement('style');
        styleElement.textContent = modalStyles;
        document.head.appendChild(styleElement);

        // Создадим модальное окно
        const modalElement = mainContainer.createEl("div", {attr: {class: "image-modal"}});
        const modalContent = modalElement.createEl("div", {attr: {class: "modal-content"}});
        modalContent.createEl("img");

        // Функция для открытия модального окна
        function openModal(imageSrc) {
            const modalImg = modalElement.querySelector('img');
            modalImg.src = imageSrc;
            modalElement.style.display = 'flex';
        }

        // Функция для закрытия модального окна
        function closeModal() {
            modalElement.style.display = 'none';
        }

        // Добавим обработчик клика для закрытия модального окна
        modalElement.addEventListener('click', closeModal);

        // Создаем элементы управления
        const filterContainer = mainContainer.createEl("div", {attr: {style: "margin-bottom: 20px; display: flex; flex-wrap: wrap; gap: 10px; align-items: center;"}});
        const inputStyle = "background-color: #2c2c2c; border: 1px solid #444; color: #e0e0e0; padding: 8px; border-radius: 4px; flex: 1;";

        keys.forEach(key => {
            filterContainer.createEl("input", {attr: {type: "text", placeholder: `Фильтр по ${key.toLowerCase()}`, style: inputStyle}});
        });

        const buttonStyle = "background-color: #4a4a4a; color: #e0e0e0; border: none; padding: 6px; border-radius: 4px; cursor: pointer; transition: background-color 0.3s; width: 30px; height: 30px; display: flex; justify-content: center; align-items: center;";
        
        const applyFilterButton = filterContainer.createEl("button", {attr: {style: buttonStyle}});
        applyFilterButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>
            </svg>
        `;

        const resetFilterButton = filterContainer.createEl("button", {attr: {style: buttonStyle}});
        resetFilterButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M2.5 2v6h6M2.66 15.57a10 10 0 1 0 .57-8.38"/>
            </svg>
        `;

        // Добавляем эффект при наведении на кнопки
        [applyFilterButton, resetFilterButton].forEach(button => {
            button.addEventListener("mouseover", () => button.style.backgroundColor = "#5a5a5a");
            button.addEventListener("mouseout", () => button.style.backgroundColor = "#4a4a4a");
        });

        // Создаем контейнер для таблицы
        const tableContainer = mainContainer.createEl("div");

        // Переменные для сортировки
        let currentSortColumn = null;
        let currentSortOrder = 'asc';

        // Функция для создания таблицы
        function createTable(items) {
            const table = tableContainer.createEl("table", {attr: {style: "width: 100%; border-collapse: separate; border-spacing: 0; border-radius: 8px; overflow: hidden;"}});
            const thead = table.createEl("thead");
            const headerRow = thead.createEl("tr");
            keys.forEach(header => {
                const th = headerRow.createEl("th", {
                    text: header,
                    attr: {
                        style: "background-color: #3a3a3a; color: #e0e0e0; padding: 12px; text-align: left; font-weight: bold; cursor: pointer;"
                    }
                });
                th.addEventListener("click", () => sortTable(header));
            });
            
            const tbody = table.createEl("tbody");
            items.forEach((item, index) => {
                const row = tbody.createEl("tr", {attr: {style: `background-color: ${index % 2 === 0 ? '#2c2c2c' : '#333333'};`}});
                
                keys.forEach(key => {
                    const cell = row.createEl("td", {attr: {style: "padding: 12px; border-top: 1px solid #444;"}});
                    const values = item[key] || ["-нет-"];
                    
                    values.forEach((value, index) => {
                        if (index > 0) {
                            cell.appendChild(document.createTextNode(", "));
                        }
                        
                        createLinkOrText(cell, value, value);
                    });
                });
            });
        }

        // Замените существующую функцию createLinkOrText на эту
        async function createLinkOrText(container, value, displayText) {
            let filePath, linkText, isMedia = false;
            const previewSize = currentFileProperties.preview_size || 100;

            // Обработка тегов
            if (value.startsWith('#')) {
                const tagSpan = container.createEl("a", {
                    text: value,
                    attr: {
                        class: "tag",
                        href: value,
                        style: "text-decoration: none; border-radius: 4px; padding: 2px 4px; font-size: 0.9em; font-weight: 500;"
                    }
                });
                return;
            }

            // Обработка медиа-ссылок вида ![[ссылка]]
            if (value.startsWith('![[') && value.endsWith(']]')) {
                isMedia = true;
                filePath = value.slice(3, -2);
            }
            // Обработка ссылок вида [Текст](Путь.md)
            else if (value.match(/\[.*?\]\(.*?\)/)) {
                const match = value.match(/\[(.*?)\]\((.*?)\)/);
                if (match) {
                    linkText = match[1];
                    filePath = decodeURIComponent(match[2]);
                }
            }
            // Обработка вики-ссылок [[Путь|Текст]]
            else if (value.startsWith('[[') && value.endsWith(']]')) {
                const content = value.slice(2, -2);
                [filePath, linkText] = content.split('|').map(s => s.trim());
            }
            else {
                // Обычный текст или некорректная ссылка
                container.appendChild(document.createTextNode(value));
                return;
            }

            // Если linkText пустой, используем filePath в качестве текста ссылки
            linkText = linkText || filePath.replace(/\.md$/, '');

            // Убедимся, что у нас есть расширение файла для не-медиа файлов
            if (!isMedia && !filePath.endsWith('.md')) {
                filePath += '.md';
            }

            // Удаляем начальный слэш, если он есть
            filePath = filePath.replace(/^\//, '');

            let file = app.vault.getAbstractFileByPath(filePath);

            if (isMedia && file) {
                // Создаем элемент изображения для медиа-файлов
                const imgElement = container.createEl("img", {
                    attr: {
                        src: app.vault.getResourcePath(file),
                        alt: linkText,
                        style: `max-width: ${previewSize}px; max-height: ${previewSize}px; width: auto; height: auto; border-radius: 4px; object-fit: contain; cursor: pointer;`
                    }
                });

                // Изменяем обработчик для открытия изображения в модальном окне при клике
                imgElement.addEventListener("click", (event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    openModal(app.vault.getResourcePath(file));
                });
            } else {
                // Создаем ссылку для не-медиа файлов
                const linkElement = container.createEl("a", {
                    text: linkText,
                    attr: {
                        href: "#",
                        style: "color: #4a9eff; text-decoration: none; position: relative;"
                    }
                });

                linkElement.addEventListener("click", async (event) => {
                    event.preventDefault();
                    if (!file) {
                        // Проверяем существование каталога и создаем его при необходимости
                        const folderPath = filePath.substring(0, filePath.lastIndexOf("/"));
                        if (folderPath && !app.vault.getAbstractFileByPath(folderPath)) {
                            try {
                                await app.vault.createFolder(folderPath);
                            } catch (error) {
                                console.error(`Ошибка при создании каталога: ${error.message}`);
                                return;
                            }
                        }

                        // Создаем файл, если он не существует
                        const fileContent = `# ${displayText}\n\n- Название: ${displayText}\n- Цвет: \n- Вес: \n- Класс: `;
                        try {
                            await app.vault.create(filePath, fileContent);
                            file = app.vault.getAbstractFileByPath(filePath);
                        } catch (error) {
                            console.error(`Ошибка при создании файла: ${error.message}`);
                            return;
                        }
                    }
                    if (file) {
                        app.workspace.activeLeaf.openFile(file);
                    }
                });

                if (file) {
                    linkElement.addClass("internal-link");
                    linkElement.setAttribute("data-href", file.path);
                    linkElement.setAttribute("href", file.path);
                    linkElement.setAttribute("target", "_blank");
                    linkElement.setAttribute("rel", "noopener");
                }

                linkElement.addEventListener("mouseover", () => linkElement.style.textDecoration = "underline");
                linkElement.addEventListener("mouseout", () => linkElement.style.textDecoration = "none");
            }
        }

        // Функция для сортировки таблицы
        function sortTable(column) {
            if (currentSortColumn === column) {
                if (currentSortOrder === 'asc') {
                    currentSortOrder = 'desc';
                } else {
                    // Сброс сортировки при третьем клике
                    currentSortColumn = null;
                    currentSortOrder = 'asc';
                }
            } else {
                currentSortColumn = column;
                currentSortOrder = 'asc';
            }

            if (currentSortColumn) {
                allItems.sort((a, b) => {
                    let valuesA = a[column] || [""];
                    let valuesB = b[column] || [""];
                    
                    // Сравниваем первые значения в массивах
                    let valueA = valuesA[0];
                    let valueB = valuesB[0];
                    
                    // Убираем [[ и ]] для сортировки, если это вики-ссылка
                    if (valueA.startsWith("[[") && valueA.endsWith("]]")) valueA = valueA.slice(2, -2);
                    if (valueB.startsWith("[[") && valueB.endsWith("]]")) valueB = valueB.slice(2, -2);
                    
                    if (valueA < valueB) return currentSortOrder === 'asc' ? -1 : 1;
                    if (valueA > valueB) return currentSortOrder === 'asc' ? 1 : -1;
                    return 0;
                });
            }

            updateTable();
        }

        // ункция для обновления таблицы
        function updateTable() {
            const filters = {};
            keys.forEach(key => {
                const filterInput = mainContainer.querySelector(`input[placeholder="Фильтр по ${key.toLowerCase()}"]`);
                if (filterInput) {
                    filters[key] = filterInput.value;
                }
            });
            const filteredItems = applyFilters(allItems, filters);
            
            // Очищаем контейнер таблицы
            tableContainer.empty();
            
            // Создаем новую таблицу с отфильтрованными и отсортированными данными
            createTable(filteredItems);

            // Добавляем индикатор сортировки
            if (currentSortColumn) {
                const headers = tableContainer.querySelectorAll("th");
                headers.forEach(header => {
                    if (header.textContent === currentSortColumn) {
                        header.textContent += currentSortOrder === 'asc' ? ' ▲' : ' ▼';
                    }
                });
            }
        }

        // Функция для сброса фильтров
        function resetFilters() {
            keys.forEach(key => {
                const filterInput = mainContainer.querySelector(`input[placeholder="Фильтр по ${key.toLowerCase()}"]`);
                if (filterInput) {
                    filterInput.value = '';
                }
            });
            currentSortColumn = null;
            currentSortOrder = 'asc';
            updateTable();
        }

        // Инициализация таблицы при первой загрузке
        updateTable();

        // Обработчики соытий
        applyFilterButton.addEventListener("click", updateTable);
        resetFilterButton.addEventListener("click", resetFilters);
    }
}

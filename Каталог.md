---
language: Dataviewjs для Obsidian
---

# Каталог

```dataviewjs
// Получаем все файлы, содержащие "Каталог товаров" в названии
const catalogPages = dv.pages().where(p => p.file.name.toLowerCase().includes("каталог товаров"));

if (catalogPages.length === 0) {
    dv.paragraph("Ошибка: Не найдено ни одной заметки, содержащей 'Каталог товаров' в названии. Убедитесь, что такие заметки существуют.");
} else {
    // Функция для парсинга содержимого заметки
    function parseItems(content, filePath) {
        const items = [];
        let currentItem = {};
        let lineNumber = 0;

        content.split('\n').forEach(line => {
            lineNumber++;
            if (line.startsWith('- Товар')) {
                if (Object.keys(currentItem).length > 0) {
                    items.push(currentItem);
                }
                currentItem = { lineNumber: lineNumber, filePath: filePath };
            } else if (line.trim().startsWith('- ')) {
                const [key, ...valueParts] = line.split(':').map(s => s.trim());
                const value = valueParts.join(':').trim(); // Обьединяем обратно, если в значении были двоеточия
                currentItem[key.replace('- ', '')] = value;
            }
        });

        if (Object.keys(currentItem).length > 0) {
            items.push(currentItem);
        }

        return items;
    }

    // Парсим содержимое всех заметок каталога
    let allItems = [];
    for (const page of catalogPages) {
        const fileContent = await dv.io.load(page.file.path);
        allItems = allItems.concat(parseItems(fileContent, page.file.path));
    }

    // Добавьте эту функцию после объявления переменной allItems
    function getCurrentFolder() {
        const currentFilePath = dv.current().file.path;
        return currentFilePath.substring(0, currentFilePath.lastIndexOf("/") + 1);
    }

    if (allItems.length === 0) {
        dv.paragraph("Предупреждение: В заметках каталога товаров не найдено данных в ожидаемом формате.");
    } else {
        // Функция для применения фильтров
        function applyFilters(items, filters) {
            return items.filter(item => {
                return Object.entries(filters).every(([key, value]) => {
                    if (!value) return true; // Пропускаем пустые фильтры
                    const itemValue = item[key] || "";
                    return itemValue.toLowerCase().includes(value.toLowerCase());
                });
            });
        }

        // Создаем контейнер для всего содержимого
        const mainContainer = dv.el("div", "", {attr: {style: "font-family: Arial, sans-serif; color: #e0e0e0;"}});

        // Создаем элементы управления
        const filterContainer = mainContainer.createEl("div", {attr: {style: "margin-bottom: 20px; display: flex; gap: 10px;"}});
        const inputStyle = "background-color: #2c2c2c; border: 1px solid #444; color: #e0e0e0; padding: 8px; border-radius: 4px; width: 33.33%;";
        const nameFilterInput = filterContainer.createEl("input", {attr: {type: "text", placeholder: "Фильтр по названию", style: inputStyle}});
        const colorFilterInput = filterContainer.createEl("input", {attr: {type: "text", placeholder: "Фильтр по цвету", style: inputStyle}});
        const buttonStyle = "background-color: #4a4a4a; color: #e0e0e0; border: none; padding: 8px; border-radius: 4px; cursor: pointer; transition: background-color 0.3s; width: 40px; height: 40px; display: flex; justify-content: center; align-items: center;";
        
        const applyFilterButton = filterContainer.createEl("button", {attr: {style: buttonStyle}});
        applyFilterButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>
            </svg>
        `;

        const resetFilterButton = filterContainer.createEl("button", {attr: {style: buttonStyle}});
        resetFilterButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M2.5 2v6h6M2.66 15.57a10 10 0 1 0 .57-8.38"/>
            </svg>
        `;

        // Добавляем эффект при наведении на кнопки
        [applyFilterButton, resetFilterButton].forEach(button => {
            button.addEventListener("mouseover", () => button.style.backgroundColor = "#5a5a5a");
            button.addEventListener("mouseout", () => button.style.backgroundColor = "#4a4a4a");
        });

        // Создаем контейнер для таблицы
        const tableContainer = mainContainer.createEl("div");

        // Переменные для сортировки
        let currentSortColumn = null;
        let currentSortOrder = 'asc';

        // Функция для создания таблицы
        function createTable(items) {
            const table = tableContainer.createEl("table", {attr: {style: "width: 100%; border-collapse: separate; border-spacing: 0; border-radius: 8px; overflow: hidden;"}});
            const thead = table.createEl("thead");
            const headerRow = thead.createEl("tr");
            ["Название", "Цвет", "Вес", "Класс"].forEach(header => {
                const th = headerRow.createEl("th", {
                    text: header,
                    attr: {
                        style: "background-color: #3a3a3a; color: #e0e0e0; padding: 12px; text-align: left; font-weight: bold; cursor: pointer;"
                    }
                });
                th.addEventListener("click", () => sortTable(header));
            });
            
            const tbody = table.createEl("tbody");
            items.forEach((item, index) => {
                const row = tbody.createEl("tr", {attr: {style: `background-color: ${index % 2 === 0 ? '#2c2c2c' : '#333333'};`}});
                
                ["Название", "Цвет", "Вес", "Класс"].forEach(key => {
                    const cell = row.createEl("td", {attr: {style: "padding: 12px; border-top: 1px solid #444;"}});
                    const value = item[key] || "Н/Д";
                    
                    if (typeof value === 'string' && value.startsWith("[[") && value.endsWith("]]")) {
                        const linkContent = value.slice(2, -2); // Убираем [[ и ]]
                        const [linkPath, linkText] = linkContent.split('|').map(s => s.trim());
                        createLinkOrText(cell, linkPath, linkText || linkPath);
                    } else {
                        cell.textContent = value;
                    }
                });
            });
        }

        // Замените существующую функцию createLinkOrText на эту
        function createLinkOrText(container, linkPath, displayText) {
            const currentFolder = getCurrentFolder();
            let filePath = linkPath.endsWith('.md') ? linkPath : linkPath + '.md';
            if (!filePath.startsWith('/')) {
                filePath = currentFolder + filePath;
            }
            const file = app.vault.getAbstractFileByPath(filePath);
            
            const linkElement = container.createEl("a", {
                text: displayText,
                attr: {
                    href: "#",
                    style: "color: #4a9eff; text-decoration: none; position: relative;"
                }
            });

            if (file) {
                linkElement.addEventListener("click", (event) => {
                    event.preventDefault();
                    app.workspace.activeLeaf.openFile(file);
                });

                // Используем встроенный механизм превью Obsidian
                linkElement.addClass("internal-link");
                linkElement.setAttribute("data-href", file.path);
                linkElement.setAttribute("href", file.path);
                linkElement.setAttribute("target", "_blank");
                linkElement.setAttribute("rel", "noopener");
            } else {
                linkElement.addEventListener("click", (event) => {
                    event.preventDefault();
                    createNewFile(linkPath, currentFolder);
                });
            }

            linkElement.addEventListener("mouseover", () => linkElement.style.textDecoration = "underline");
            linkElement.addEventListener("mouseout", () => linkElement.style.textDecoration = "none");
        }

        // Замените существующую функцию createNewFile на эту
        async function createNewFile(fileName, currentFolder) {
            const filePath = currentFolder + (fileName.endsWith('.md') ? fileName : fileName + '.md');
            const fileContent = `# ${fileName}\n\n- Название: ${fileName}\n- Цвет: \n- Вес: \n- Класс: `;
            
            try {
                await app.vault.create(filePath, fileContent);
                new Notice(`Файл "${fileName}" успешно создан в папке ${currentFolder}`);
                
                const file = app.vault.getAbstractFileByPath(filePath);
                if (file) {
                    app.workspace.activeLeaf.openFile(file);
                }
            } catch (error) {
                new Notice(`Ошибка при создании файла: ${error.message}`);
            }
        }

        // Функция для сортировки таблицы
        function sortTable(column) {
            if (currentSortColumn === column) {
                if (currentSortOrder === 'asc') {
                    currentSortOrder = 'desc';
                } else {
                    // Сброс сортировки при третьем клике
                    currentSortColumn = null;
                    currentSortOrder = 'asc';
                }
            } else {
                currentSortColumn = column;
                currentSortOrder = 'asc';
            }

            if (currentSortColumn) {
                allItems.sort((a, b) => {
                    let valueA = a[column] || "";
                    let valueB = b[column] || "";
                    // Убираем [[ и ]] для сортировки, если это вики-ссылка
                    if (valueA.startsWith("[[") && valueA.endsWith("]]")) valueA = valueA.slice(2, -2);
                    if (valueB.startsWith("[[") && valueB.endsWith("]]")) valueB = valueB.slice(2, -2);
                    if (valueA < valueB) return currentSortOrder === 'asc' ? -1 : 1;
                    if (valueA > valueB) return currentSortOrder === 'asc' ? 1 : -1;
                    return 0;
                });
            }

            updateTable();
        }

        // ункция для обновления таблицы
        function updateTable() {
            const filters = {
                "Название": nameFilterInput.value,
                "Цвет": colorFilterInput.value
            };
            const filteredItems = applyFilters(allItems, filters);
            
            // Очищаем контейнер таблицы
            tableContainer.empty();
            
            // Создаем новую таблицу с отфильтрованными и отсортированными данными
            createTable(filteredItems);

            // Добавляем индикатор сортировки
            if (currentSortColumn) {
                const headers = tableContainer.querySelectorAll("th");
                headers.forEach(header => {
                    if (header.textContent === currentSortColumn) {
                        header.textContent += currentSortOrder === 'asc' ? ' ▲' : ' ▼';
                    }
                });
            }
        }

        // Функция для сброса фильтров
        function resetFilters() {
            nameFilterInput.value = '';
            colorFilterInput.value = '';
            currentSortColumn = null;
            currentSortOrder = 'asc';
            updateTable();
        }

        // Инициализация таблицы при первой загрузке
        updateTable();

        // Обработчики соытий
        applyFilterButton.addEventListener("click", updateTable);
        resetFilterButton.addEventListener("click", resetFilters);
    }
}
